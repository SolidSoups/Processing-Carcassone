/* autogenerated by Processing revision 1286 on 2024-01-23 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {

GameController gc;

final int TILE_SIZE = 100;

 public void setup(){
    /* size commented out by preprocessor */;

    gc = new GameController();
}

 public void draw(){
    background(0);

    gc.update();
    gc.render();
}

 public void mousePressed(){
    if(mouseButton == LEFT){
        gc.leftMousePressed();
    }
    if( mouseButton == RIGHT){
        gc.rightMousePressed();
    }
}
class GameController{
    ArrayList<Tile> tiles;

    // sprites
    PImage[] sprites;
    int spriteSize = 24;

    // cursor
    int selectedSpriteIndex;
    VectorInt snappedMousePosition;

    // input
    private boolean previewPlacement = false;
    private Tile previewTile;
    private boolean confirmPlacement = false;

    public GameController(){
        tiles = new ArrayList<Tile>();
        sprites = new PImage[spriteSize];
        
        // initialize all spries
        for(int i = 0; i < spriteSize; i++){
            String s = str(i);
            while( s.length() < 2)
                s = "0" + s;
            sprites[i] = loadImage("resources/sprites/sprite_" + s + ".png"); // idk why these images are in png lol
        }
        selectNewRandomSprite();

        //add middle tile
        Vector middlePos = new Vector(width/2, height/2);
        VectorInt middleGridPos = middlePos.returnGridPos();
        Tile starterTile = new Tile(middleGridPos, sprites[14]);
        tiles.add(starterTile);
    }




    // Functionality

     public void update(){
        // check current snappedMousePosition
        Vector mousePosition = new Vector(mouseX, mouseY);
        snappedMousePosition = mousePosition.snapToGrid();

        if(this.previewPlacement && this.confirmPlacement){
            placeTile();
            this.confirmPlacement = false;
            this.previewPlacement = false;
        }
    }

     public void selectNewRandomSprite(){
        selectedSpriteIndex = PApplet.parseInt(random(0, spriteSize));
    }

     public void placeTile(){
        // creation
        Tile newTile = new Tile(previewTile.getGridPosition(), sprites[selectedSpriteIndex]);
        previewTile = null;
        selectNewRandomSprite();

        this.tiles.add(newTile);
    }




    // Graphics

    public void render(){
        renderGraphics();
        renderUI();
    }
    
    public void renderGraphics(){
        for(Tile t : tiles){
            t.draw();
        }
        if(previewPlacement){
            previewTile.draw();
        }
    }





    // UI

    public void renderUI(){
        drawCursor();
        drawNextTile();
    }

    public void drawCursor(){
        if( !validTilePlacement(snappedMousePosition.returnGridPosition()))
            return;

        

        pushMatrix();
        pushStyle();
        
        translate(snappedMousePosition.x, snappedMousePosition.y);
        rectMode(CORNER);
        noStroke();
        fill(255, 120);
        rect(0, 0, TILE_SIZE, TILE_SIZE);
        
        popStyle();
        popMatrix();
    }

    public void drawNextTile(){
        // get bottom right corner location
        float boxDelta = 0.2f;
        PVector boxSize = new PVector(height * boxDelta, height * boxDelta);
        PVector drawLoc = new PVector(width - boxSize.x, 0);
        float padding = height * boxDelta * 0.1f;
        PVector frameSize = new PVector(boxSize.x-padding*2, boxSize.y-padding*2);

        pushMatrix();

        translate(drawLoc.x, drawLoc.y);
        fill(120, 120, 150);
        noStroke();
        rectMode(CORNER);
        rect(0, 0, boxSize.x, boxSize.y);
        translate(padding, padding);
        imageMode(CORNER);
        image(sprites[selectedSpriteIndex], 0, 0, frameSize.x, frameSize.y);

        popMatrix();
    }




    // input
    public void leftMousePressed(){
        VectorInt previewLocation = this.snappedMousePosition.returnGridPosition();

        if( !validTilePlacement(previewLocation) )
            return;

        previewTile = new Tile(previewLocation, sprites[selectedSpriteIndex]);
        this.previewPlacement = true;
    }

    public void rightMousePressed(){
        if( previewPlacement ){
            previewTile.rotateTile();
        }
    }



    // boolean methods
     public boolean validTilePlacement(VectorInt gridPosition){
        // validity
        if( !hasNeighbours(gridPosition) ){
            return false;
        }
        for(Tile refTile : this.tiles){
            VectorInt refTile_position = refTile.getGridPosition();
            if( refTile_position.x == gridPosition.x && refTile_position.y == gridPosition.y ){
                return false;
            }
        }

        return true;
    }

     public boolean hasNeighbours(VectorInt gridPosition){
        int[][] theFourHorsemen = {{-1,0}, {0,-1}, {1,0}, {0,1}};
        for(Tile t : tiles){
            VectorInt tPos = t.getGridPosition();
            for(int i = 0; i < 4; i++){
                int dX = (gridPosition.x + theFourHorsemen[i][0]);
                int dY = (gridPosition.y + theFourHorsemen[i][1]);
                if( tPos.x == dX && tPos.y == dY)
                    return true;
            }
        }

        return false;
    }
}
class Tile{
    VectorInt gridPosition;
    int c;
    PImage sprite;

    // directions
    public final int NORTH = 0;
    public final int EAST  = 1;
    public final int SOUTH = 2;
    public final int WEST  = 3;
    public final int[] directions = {this.NORTH, this.EAST, this.SOUTH, this.WEST};
    int selectedDirectionIndex = 0;


    public Tile(VectorInt gridPosition, PImage sprite){
        // randomizing tile color
        int r = PApplet.parseInt(random(0,255));
        int g = PApplet.parseInt(random(0,255));
        int b = PApplet.parseInt(random(0,255));

        c = color(r, g, b);

        this.gridPosition = gridPosition;
        this.sprite = sprite;
    }



    public void draw(){
        PVector drawPosition = gridPosition.scaleToGrid();
        
        pushMatrix();
        translate(drawPosition.x + TILE_SIZE/2, drawPosition.y + TILE_SIZE/2);
        pushStyle();
        imageMode(CENTER);

        // change direction if needed
        float rotation = directions[selectedDirectionIndex] * HALF_PI;
        rotate(rotation);

        image(sprite, 0, 0, TILE_SIZE, TILE_SIZE);
        popStyle();
        popMatrix();
    }

    public VectorInt getGridPosition(){
        return this.gridPosition;
    }

    public void rotateTile(){
        if( selectedDirectionIndex < (directions.length - 1) )
            selectedDirectionIndex += 1;
        else
            selectedDirectionIndex = 0;
    }
}
class Vector extends PVector{
    Vector(float x, float y){
        super(x, y);
    }

    public VectorInt snapToGrid(){
        int x = PApplet.parseInt(this.x / TILE_SIZE) * TILE_SIZE;
        int y = PApplet.parseInt(this.y / TILE_SIZE) * TILE_SIZE;
        return new VectorInt(x, y);
    }

    public VectorInt returnGridPos(){
        int x = PApplet.parseInt(this.x / TILE_SIZE);
        int y = PApplet.parseInt(this.y / TILE_SIZE);
        return new VectorInt(x, y);
    }
}
class VectorInt{
    public int x, y;

    VectorInt(int x, int y){
        this.x = x;
        this.y = y;
    }

    public PVector scaleToGrid(){
        float x = this.x * TILE_SIZE;
        float y = this.y * TILE_SIZE;
        return new PVector(x, y);
    }

    public VectorInt returnGridPosition(){
        int x = PApplet.parseInt(this.x / TILE_SIZE);
        int y = PApplet.parseInt(this.y / TILE_SIZE);
        return new VectorInt(x, y);
    }

    @Override
    public String toString(){
        return "(" + this.x + ", " + this.y + ")";
    }

    public VectorInt mult(int d){
        this.x = this.x * d;
        this.y = this.y * d;
        return this;
    }

    public VectorInt mult(float d){
        this.x = PApplet.parseInt(this.x * d);
        this.y = PApplet.parseInt(this.y * d);
        return this;
    }

    public VectorInt asNew(){
        return new VectorInt(this.x, this.y);
    }
}


  public void settings() { size(1500, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
