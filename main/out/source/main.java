/* autogenerated by Processing revision 1286 on 2024-01-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {

GameController gc;

final int TILE_SIZE = 100;

 public void setup(){
    /* size commented out by preprocessor */;

    gc = new GameController();
    gc.addTile(new Tile(new VectorInt(2, 5)));
}

 public void draw(){
    background(0);

    gc.renderTiles();
}

 public void mousePressed(){
    if(mouseButton == LEFT){
        Vector mousePos = new Vector(mouseX, mouseY);
        VectorInt snappedMousePos = mousePos.returnGridPos();
        
        gc.addTile(new Tile(snappedMousePos));
    }
}
class GameController{
    ArrayList<Tile> tiles;

    public GameController(){
        tiles = new ArrayList<Tile>();
    }

    public void renderTiles(){
        for(Tile t : tiles){
            t.draw();
        }

        drawMouse();
    }

    public void drawMouse(){
        Vector mousePosition = new Vector(mouseX, mouseY);
        VectorInt snappedMousePosition = mousePosition.snapToGrid();

        pushMatrix();
        translate(snappedMousePosition.x, snappedMousePosition.y);
        rectMode(CORNER);
        noFill();
        stroke(255);
        strokeWeight(4);
        rect(0, 0, TILE_SIZE, TILE_SIZE);
        popMatrix();
    }

    public void addTile(Tile newTile){
        VectorInt newTile_position = newTile.getGridPosition();
        for(Tile refTile : this.tiles){
            VectorInt refTile_position = refTile.getGridPosition();
            if( refTile_position.x == newTile_position.x && refTile_position.y == newTile_position.y ){
                println("Tile already exists at location " + refTile_position);
                return;
            }
        }


        this.tiles.add(newTile);
    }
}
class Tile{
    VectorInt gridPosition;
    int c;


    public Tile(VectorInt gridPosition){
        // randomizing tile color
        int r = PApplet.parseInt(random(0,255));
        int g = PApplet.parseInt(random(0,255));
        int b = PApplet.parseInt(random(0,255));

        c = color(r, g, b);

        this.gridPosition = gridPosition;
    }

    public void draw(){
        PVector drawPosition = gridPosition.scaleToGrid();

        pushMatrix();
        translate(drawPosition.x + TILE_SIZE/2, drawPosition.y + TILE_SIZE/2);
        rectMode(CENTER);
        fill(c);
        noStroke();
        rect(0, 0, TILE_SIZE, TILE_SIZE);
        popMatrix();
    }

    public VectorInt getGridPosition(){
        return this.gridPosition;
    }
}
class Vector extends PVector{
    Vector(float x, float y){
        super(x, y);
    }

    public VectorInt snapToGrid(){
        int x = PApplet.parseInt(this.x / TILE_SIZE) * TILE_SIZE;
        int y = PApplet.parseInt(this.y / TILE_SIZE) * TILE_SIZE;
        return new VectorInt(x, y);
    }

    public VectorInt returnGridPos(){
        int x = PApplet.parseInt(this.x / TILE_SIZE);
        int y = PApplet.parseInt(this.y / TILE_SIZE);
        return new VectorInt(x, y);
    }
}
class VectorInt{
    public int x, y;

    VectorInt(int x, int y){
        this.x = x;
        this.y = y;
    }

    public PVector scaleToGrid(){
        float x = this.x * TILE_SIZE;
        float y = this.y * TILE_SIZE;
        return new PVector(x, y);
    }

    @Override
    public String toString(){
        return "(" + this.x + ", " + this.y + ")";
    }
}


  public void settings() { size(1000, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
