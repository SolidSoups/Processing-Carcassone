/* autogenerated by Processing revision 1286 on 2024-01-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.security.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {

GameController gc;

// variables
final float     targetMargin = 100;
final int       boundsLength = 20;
      int       TILE_SIZE;
      VectorInt PLAY_AREA_SIZE;

// directions
public final int GRASS = 0;
public final int ROAD  = 1;
public final int CITY  = 2;
public final int EMPTY = 3;
public final String[] TYPE_NAMES = {"Grass", "Road", "City", "Empty"};

public final int NORTH = 0;
public final int EAST  = 1;
public final int SOUTH = 2;
public final int WEST  = 3;
public final String[] DIRECTION_NAMES = {"North", "East", "South", "West"};

// use this maybe???
enum FaceType{
    GRASS   (0, "Grass"),
    ROAD    (1, "Road"),
    CITY    (2, "City"),
    EMPTY   (3, "Empty");

    private final int       index;
    private final String    label;
    FaceType(int index, String label){
        this.index = index;
        this.label = label;
    }

    @Override
    public String toString(){
        return this.label;
    }
}

public final int NULL  = 100;

public final boolean DEBUG_MODE = true;

 public void setup(){
    /* size commented out by preprocessor */;
    println("---Program start.");

    TILE_SIZE = PApplet.parseInt((width - targetMargin*2) / boundsLength);
    PLAY_AREA_SIZE = new VectorInt(
        boundsLength,
        PApplet.parseInt((height - targetMargin*2) / TILE_SIZE)
    );
    println("TILE_SIZE: \t\t" + TILE_SIZE);
    println("PLAY_AREA_SIZE: \t" + PLAY_AREA_SIZE);

    gc = new GameController();
}

 public void draw(){
    background(0);

    gc.Update();
    gc.Render();
}


 public void mousePressed(){
    if(mouseButton == LEFT){
        gc.LeftMousePressed();
    }
    if( mouseButton == RIGHT){
        gc.RightMousePressed();
    }
}

// bound a direction between 0, 1, 2, 3
 public int BoundDirection(int direction){
    int x = direction;
    if( x < 0 ){
        x += 4;
        x = BoundDirection(x);
    }
    else if( x > 3){
        x -= 4;
        x = BoundDirection(x);
    }
    return x;
}


class GameController{
    Tile[][] placedTilesArray;
    TileData[] tileDataList;

    // handlers
    GraphicsHandler graphicsHandler;
    UIHandler uiHandler;

    // sprites
    PImage[] sprites;
    int spriteSize = 24;

    // input
    private boolean isPreviewingPlacement = false;
    private boolean hasConfirmedPlacement = false;
    private Tile previewTile;

    // preview tile properties
    private int         previewTileSpriteID;
    private VectorInt   previewTileGridPosition;
    private int         previewTileRotation;
    private IntList     previewCorrectTileRotations         = new IntList();
    private int         previewCorrectTileRotationsIndex    = 0;

    // finals
    final int[][] theFourHorsemen = {{0,-1}, {1,0}, {0,1}, {-1,0}};

    ArrayList<VectorInt>    possiblePlacements             = new ArrayList<VectorInt>();
    IntList                 possiblePlacementsRotations    = new IntList();




    // CONSTRUCTOR
    public GameController(){
        // load all sprites and their data files
        sprites = new PImage[spriteSize];
        tileDataList = new TileData[spriteSize];
        tileDataList = this.LoadTilesFromJSON();

        // create array for placed tiles
        placedTilesArray = new Tile[PLAY_AREA_SIZE.x][PLAY_AREA_SIZE.y];

        // init handlers
        graphicsHandler = new GraphicsHandler(this);
        uiHandler = new UIHandler(this);

        // init all sprites
        for(int i = 0; i < spriteSize; i++){
            String s = str(i);
            while( s.length() < 2)
                s = "0" + s;
            sprites[i] = loadImage("resources/sprites/sprite_" + s + ".png");
        }

        // add starter tile
        Tile starterTile = new Tile(new VectorInt(6,6), 14);
        placedTilesArray[6][6] = starterTile;

        
        this.SelectNewRandomSprite();
    }









    // MAIN METHODS

     public void Update(){
        // place a tile if we have confirmed our placed
        if(this.isPreviewingPlacement && this.hasConfirmedPlacement){
            PlaceTile();
            ClearPlacementFlags();
            SelectNewRandomSprite();
        }
    }

    public void Render(){
        graphicsHandler.Render();
        uiHandler.Render();
    }





    // FUNCTIONALITY

    // changes the next sprite to a random sprite
     public void SelectNewRandomSprite(){
        println("Selecting new random sprite!");
        previewTileSpriteID = PApplet.parseInt(random(0, spriteSize));
        if(!IsPlacementPossible()){
            SelectNewRandomSprite();
        }
    }

    // places a tile at the current preview position
     public void PlaceTile(){
        Tile newTile = new Tile(previewTileGridPosition, previewTileSpriteID, previewTileRotation);
        this.placedTilesArray[previewTileGridPosition.x][previewTileGridPosition.y] = newTile;
    }

    // clear preview and confirm placement flags
     public void ClearPlacementFlags(){
        this.hasConfirmedPlacement = false;
        this.isPreviewingPlacement = false;
        previewCorrectTileRotations.clear();
        previewCorrectTileRotationsIndex = 0;
    }

    // HELLO ROZA   ! ! ! ! ! ! <3
    //
    //     |\__/,|   (`\
    //   _.|o o  |_   ) )
    // -(((---(((--------
    //
    
    // returns the cell position of where the mouse is hovering
     public VectorInt MouseToGridPosition(){
        PVector offsetMousePos = new PVector(mouseX-targetMargin, mouseY-targetMargin);
        if( offsetMousePos.x < 0 || offsetMousePos.y < 0 || offsetMousePos.x >= (PLAY_AREA_SIZE.x*TILE_SIZE) || offsetMousePos.y >= (PLAY_AREA_SIZE.y*TILE_SIZE) )
            return null;
        
        return new VectorInt( PApplet.parseInt(offsetMousePos.x / TILE_SIZE), PApplet.parseInt(offsetMousePos.y / TILE_SIZE) );
    }

     public void GenerateCorrectRotations(VectorInt _gridPosition){
        previewCorrectTileRotationsIndex = 0;
        previewCorrectTileRotations.clear();

        boolean[] correctRotations = IsConnectionPossible(_gridPosition, previewTileSpriteID);

        for(int i=0; i<4; i++){
            if(correctRotations[i])
                previewCorrectTileRotations.append(i);
        }
        previewTileRotation = previewCorrectTileRotations.get(0);
    }




    // INPUT CONTROL

    public void LeftMousePressed(){
        // check for UI click
        if( uiHandler.isInsideUI() ){
            int buttonPressed = uiHandler.LeftMousePressed();
            if( buttonPressed == uiHandler.CANCEL){
                ClearPlacementFlags();
            }
            else if( buttonPressed == uiHandler.CONFIRM){
                this.hasConfirmedPlacement = true;
            }
            return;
        }

        if( !MouseWithinPlayarea() )
            return;

        VectorInt mouseGridPos = MouseToGridPosition();
        if( mouseGridPos == null ) return;

        if( !IsValidTilePlacement(mouseGridPos) )
            return;
        
        // generate correct rotations
        GenerateCorrectRotations(mouseGridPos);

        previewTileGridPosition = mouseGridPos;
        this.isPreviewingPlacement = true;
    }

    public void RightMousePressed(){
        if( isPreviewingPlacement ){
            previewCorrectTileRotationsIndex++;
            if(previewCorrectTileRotationsIndex > (previewCorrectTileRotations.size()-1))
                previewCorrectTileRotationsIndex = 0;
            previewTileRotation = previewCorrectTileRotations.get(previewCorrectTileRotationsIndex);
        }
    }

    public int[] RetrieveSurroundingFaceTypes(VectorInt _gridPosition){
        int[] facesList = new int[4];
        for(int i=0; i<4; i++){
            // check a certain position around _gridLocation
            VectorInt checkPosition = new VectorInt(
                _gridPosition.x + theFourHorsemen[i][0],
                _gridPosition.y + theFourHorsemen[i][1]
            );
            // get the tile or null at that location
            if( checkPosition.x < 0 || checkPosition.x >= PLAY_AREA_SIZE.x ||
            checkPosition.y < 0 || checkPosition.y >= PLAY_AREA_SIZE.y )
                continue;
            Tile checkTile = this.placedTilesArray[checkPosition.x][checkPosition.y];
            
            // set facetype depending on if there is a tile or not
            int faceType;
            if(checkTile == null)
                faceType = EMPTY;
            else{
                int checkSpriteID =  checkTile.getSpriteID();
                int[] dataTilePortList = tileDataList[checkSpriteID].getPortTypes();
                int[] rotatedDataList = RotateList(dataTilePortList, checkTile.getRotation());
                faceType = rotatedDataList[BoundDirection(i+2)];
            }

            // add that type to the facesList
            facesList[i] = faceType;
        }
        return facesList;
    }

    // Rotates a given list a certain amount of times given by rotation count
    private int[] RotateList(int[] _list, int _rotateCount){
        // rotate list
        int[] rotatedList = _list;
        for(int i=0; i<_rotateCount; i++){
            int[] newList = {
                rotatedList[3],
                rotatedList[0],
                rotatedList[1],
                rotatedList[2]
            };
            rotatedList = newList;
        }
        return rotatedList;
    }






    // JSON METHODS

     public TileData[] LoadTilesFromJSON(){
        String filename = "tileConnections.json";
        JSONArray tilePieces = loadJSONArray(filename);
        TileData[] loadedTiles = new TileData[tilePieces.size()];

        // loop through available loaded Tile objects
        for (int i=0; i < tilePieces.size(); i++){
            // variables for each tile object
            int tileID;
            int[] portTypes = new int[4];
            boolean[][] portConnections = new boolean[4][4];
            
            // load tile object at index
            JSONObject tile = tilePieces.getJSONObject(i);

            // retrieve tile id
            tileID = tile.getInt("id");

            // retrieve tile portTypes
            JSONArray portTypesArray   = tile.getJSONArray("portTypes");
            portTypes = portTypesArray.toIntArray();

            // retrieve boolean portsConnections
            JSONArray portsConnectionsX = tile.getJSONArray("portConnections");
            for(int x=0; x<4; x++){
                JSONArray portsConnectionsY = portsConnectionsX.getJSONArray(x);
                for(int y=0; y<4; y++){
                    portConnections[x][y] = portsConnectionsY.getBoolean(y);
                }
            }

            // add a tile with this information
            TileData newTileData = new TileData(tileID, portTypes, portConnections);
            loadedTiles[i] = newTileData;
        }

        println("\nLoaded " + loadedTiles.length + " tiles from JSON file!");
        return loadedTiles;
    }





    // BOOLEAN METHODS

    // is a location valid for a placement?
    public boolean IsValidTilePlacement(VectorInt _gridPosition){
        if( this.placedTilesArray[_gridPosition.x][_gridPosition.y] != null )
            return false;
        if( !HasNeighbours(_gridPosition) )
            return false;

        // we check if our tile can even be here
        boolean[] _gridPositionCorrectRotations = IsConnectionPossible(_gridPosition, previewTileSpriteID);
        boolean noRotations = false;
        for(int i=0; i<4; i++)
            noRotations = noRotations || _gridPositionCorrectRotations[i];
        if(!noRotations)
            return false;

        return true;
    }

    // Returns true if at least one direct neighbour next to a given grid position
     public boolean HasNeighbours(VectorInt _gridPosition){
        for(int i = 0; i < 4; i++){
            VectorInt checkLocation = new VectorInt(
                _gridPosition.x + theFourHorsemen[i][0],
                _gridPosition.y + theFourHorsemen[i][1]
            );
            if( checkLocation.x < 0 || checkLocation.x >= PLAY_AREA_SIZE.x ||
            checkLocation.y < 0 || checkLocation.y >= PLAY_AREA_SIZE.y )
                continue;
            if(this.placedTilesArray[checkLocation.x][checkLocation.y] != null)
                return true;
        }
        return false;
    }

    // Returns true if the mouse is within the play area
     public boolean MouseWithinPlayarea(){
        if( mouseX <= targetMargin || mouseY <= targetMargin ||
        mouseX >= (targetMargin + PLAY_AREA_SIZE.x*TILE_SIZE) ||
        mouseY >= (targetMargin + PLAY_AREA_SIZE.y*TILE_SIZE))
            return false;
        return true;
    }

    // Returns a boolean list of possible rotations where the index is the rotation at a given grid location with a given tile
     public boolean[] IsConnectionPossible(VectorInt _gridPosition, int _spriteID){
        // get a list of connections at point
        int[] connectionsList = RetrieveSurroundingFaceTypes(_gridPosition);

        // retrieve _spriteID connection list
        int[] tileConnections = tileDataList[_spriteID].getPortTypes();

        // Rotates the tile and adds a boolean item determining if the lists match at that certain rotation
        boolean[] answer = new boolean[4];
        for(int i=0; i<4; i++){
            int[] rotatedList = RotateList(tileConnections, i);
            answer[i] = IsTypeListsMatchable(rotatedList, connectionsList);
        }
        return answer;
    }

    // Checks if two face type lists can match
    private boolean IsTypeListsMatchable(int[] _tileTypeList, int[] _surrTypeList){
        for(int i=0; i<4; i++){
            if(_surrTypeList[i] == EMPTY)
                continue;
            if(_surrTypeList[i] != _tileTypeList[i])
                return false;
        }
        return true;
    }

    public boolean IsPlacementPossible(){
        possiblePlacements.clear();
        possiblePlacementsRotations.clear();
        for(int x=0; x<PLAY_AREA_SIZE.x; x++){
            for(int y=0; y<PLAY_AREA_SIZE.y; y++){
                VectorInt pos = new VectorInt(x, y);
                if(IsValidTilePlacement(pos))
                    possiblePlacements.add(pos);
                else
                    continue;
                boolean[] rotations = IsConnectionPossible(pos, previewTileSpriteID);
                int count = 0;
                for(int i=0; i<4; i++){
                    if(rotations[i]) count++;
                }
                possiblePlacementsRotations.append(count);
            }
        }

        if(possiblePlacements.size() != 0)
            return true;
        return false;
    }



    // GET METHODS

    public PImage getTileSprite(int spriteID){
        return this.sprites[spriteID];
    }
    public TileData getTileData(int tileID){
        for(TileData td : tileDataList){
            if( td.getSpriteID() == tileID )
                return td;
        }
        return null;
    }

    public Tile[][] GetPlacedTilesArray(){
        return this.placedTilesArray;
    }

    public int GetPreviewTileSpriteID(){
        return this.previewTileSpriteID;
    }
    public VectorInt GetPreviewTileGridPosition(){
        return this.previewTileGridPosition;
    }
    public int GetPreviewTileRotation(){
        return this.previewTileRotation;
    }
    public IntList GetPreviewTileCorrectTileRotations(){
        return this.previewCorrectTileRotations;
    }
    public int GetPreviewTileCorrectTileRotationsIndex(){
        return this.previewCorrectTileRotationsIndex;
    }

    public boolean isPreviewingPlacement(){
        return this.isPreviewingPlacement;
    }

    public PImage getNextSprite(){
        return this.sprites[previewTileSpriteID];
    }

    public ArrayList<VectorInt> GetPossiblePlacements(){
        return this.possiblePlacements;
    }

    public IntList GetPossiblePlacementsRotations(){
        return this.possiblePlacementsRotations;
    }
}
class GraphicsHandler{
    // Game Controller reference
    private GameController gc;

    public GraphicsHandler(GameController gc){
        this.gc = gc;
    }

    public void Render(){
        if(DEBUG_MODE){
            RenderGridBounds();
            RenderPossiblePlacements();
        } 
        RenderTiles();
        if(gc.isPreviewingPlacement())
            RenderPreviewTile();
        
        if(DEBUG_MODE) RenderMouseGridLocation();
    }

    private void RenderTiles(){
        Tile[][] pt = gc.GetPlacedTilesArray();
        for(int x = 0; x < PLAY_AREA_SIZE.x; x++){
            for(int y = 0; y < PLAY_AREA_SIZE.y; y++){
                Tile tileToRender = pt[x][y];
                if( tileToRender == null ) continue;
                this.RenderTile(tileToRender.getSpriteID(), tileToRender.getRotation(), new VectorInt(x, y), false);
            }
        }
    }

    private void RenderPreviewTile(){
        this.RenderTile(gc.GetPreviewTileSpriteID(), gc.GetPreviewTileRotation(),  gc.GetPreviewTileGridPosition(), true);
    }

    private void RenderTile(int spriteID, int rotation, VectorInt gridLocation, boolean highlight){
        PImage      sprite          = gc.getTileSprite(spriteID);

        PVector drawLocation = new PVector(
            gridLocation.x * TILE_SIZE, 
            gridLocation.y * TILE_SIZE
        );
    
        pushMatrix();
        translate(
            targetMargin + TILE_SIZE/2, 
            targetMargin + TILE_SIZE/2);
        translate(
            drawLocation.x,
            drawLocation.y);
        pushStyle();
        imageMode(CENTER);

        // change direction if needed
        rotate(rotation * HALF_PI);

        if( highlight )
            tint(170, 170, 170, 150);
        image(
            sprite, 
            0, 0, 
            TILE_SIZE, TILE_SIZE );
        if(DEBUG_MODE){
            stroke(255,0,0);
            strokeWeight(2);
            line(0,0,0,-TILE_SIZE/2);
        }
        popStyle();
        popMatrix();
    }

    // Debug

    private void RenderPossiblePlacements(){
        pushMatrix();
        translate(targetMargin + TILE_SIZE/2, targetMargin + TILE_SIZE/2);

        pushStyle();
        noStroke();


        rectMode(CENTER);
        textAlign(CENTER, CENTER);
        textSize(20);
        for(int i=0; i<gc.GetPossiblePlacements().size(); i++){
            VectorInt v = gc.GetPossiblePlacements().get(i);
            PVector drawPosition = new PVector(v.x * TILE_SIZE, v.y * TILE_SIZE);
            fill(200,100,100);
            rect(drawPosition.x, drawPosition.y, TILE_SIZE/2, TILE_SIZE/2);
            fill(0);
            text(gc.GetPossiblePlacementsRotations().get(i), drawPosition.x, drawPosition.y);
        }

        

        popStyle();
        popMatrix();
    }

    private void RenderGridBounds(){
        pushMatrix();
        translate(targetMargin, targetMargin);

        // draw a light gridmap with numbers
        for(int x = 0; x < PLAY_AREA_SIZE.x; x++){
            for(int y = 0; y < PLAY_AREA_SIZE.y; y++){
                noFill();
                strokeWeight(1);
                rect(
                    x*TILE_SIZE,
                    y*TILE_SIZE,
                    TILE_SIZE,
                    TILE_SIZE
                );
            }
        }
        
        // draw the boundaries
        noFill();
        stroke(255,0,0);
        strokeWeight(2);
        rect(0, 0, PLAY_AREA_SIZE.x*TILE_SIZE, PLAY_AREA_SIZE.y*TILE_SIZE);
        popMatrix();
    }

    private void RenderMouseGridLocation(){
        VectorInt mouseGridPosition = gc.MouseToGridPosition();
        pushStyle();
        fill(255,0,0);

        textAlign(TOP, BOTTOM);
        textSize(25);
        text(mouseGridPosition == null ? "null" : mouseGridPosition.toString(), mouseX + 20, mouseY + 40);

        popStyle();
    }
}
class Tile{
    int         rotation = 0;

    VectorInt   gridPosition;
    int         tileID;

    // main constructor
    public Tile(VectorInt gridPosition, int tileID){
        this.gridPosition = gridPosition;
        this.tileID = tileID;
        this.rotation = NORTH;
    }

    // place tile constructor
    public Tile(VectorInt gridPosition, int tileID, int rotation){
        this.gridPosition = gridPosition;
        this.tileID = tileID;
        this.rotation = rotation;
    }

    // getters
    public int getSpriteID(){
        return this.tileID;
    }
    public VectorInt getGridPosition(){
        return this.gridPosition;
    }
    public int getRotation(){
        return this.rotation;
    }
}
class TileData{
    int tileID;
    int[] portTypes;
    boolean[][] portConnections;

    TileData(int tileID, int[] portTypes, boolean[][] portConnections){
        this.tileID = tileID;
        this.portTypes = portTypes;
        this.portConnections = portConnections;
    }

    public int getSpriteID(){
        return this.tileID;
    }

    // return entire port types list
    public int[] getPortTypes(){
        return this.portTypes;
    }

    // return port type at compass direction
    public int getPortType(int i){
        return this.portTypes[i];
    }
}
class UIHandler{
    // GameController reference
    GameController gc;


    // color scheme
    int grayBoxing = color(90, 90, 110);

    // locations of button controls
    PVector buttonCancelLoc;
    PVector buttonConfirmLoc;

    // leftMouseDown
    boolean leftMousePressed = false;

    // references
    final int CANCEL = 0;
    final int CONFIRM = 1;
    final int NONE = 3;
    
    // conditional button parameters
    PVector buttonBoxSize   = new PVector(width*0.05f, height*0.16f);
    float padding           = buttonBoxSize.x*0.25f;
    float boxRadius         = buttonBoxSize.x*0.5f;
    float buttonRadius      = boxRadius*0.75f;
    PVector drawLoc         = new PVector(width - (padding + buttonBoxSize.x), height - (padding + buttonBoxSize.y));

    public UIHandler(GameController gc){
        this.gc = gc;

        
        buttonCancelLoc = new PVector(drawLoc.x + boxRadius, drawLoc.y + boxRadius);
        buttonConfirmLoc = new PVector(drawLoc.x + boxRadius, drawLoc.y + buttonBoxSize.y - boxRadius);
    }


    public void Render(){
        VectorInt gridMousePosition = gc.MouseToGridPosition();

        if( gridMousePosition != null && gc.IsValidTilePlacement(gridMousePosition) )
            drawHighlightedPlacement(gridMousePosition);
        
        drawNextTile();

        if( gc.isPreviewingPlacement() ){
            drawConditionalButton();
            if( DEBUG_MODE )
                drawPreviewVariables();
        }

    }

    private void drawPreviewVariables(){
        int spriteID = gc.GetPreviewTileSpriteID();
        VectorInt gridPosition = gc.GetPreviewTileGridPosition();
        int tileRotation = gc.GetPreviewTileRotation();
        int[] mainFaces = gc.getTileData(spriteID).getPortTypes();
        int[] surroundingFaces = gc.RetrieveSurroundingFaceTypes(gridPosition);
        IntList correctTileRotations = gc.GetPreviewTileCorrectTileRotations();
        int correctTileRotationsIndex = gc.GetPreviewTileCorrectTileRotationsIndex();
        
        
        pushMatrix();
        pushStyle();
        textAlign(TOP, CENTER);

        translate(20, 20);

        fill(120,120,120,120);
        stroke(255,0,0);
        strokeWeight(2);
        rect(0,0,440,215);

        translate(20,20);

        fill(255,0,0);
        textSize(20);

        text("Sprite ID: " + spriteID, 0, 0);
        text("Grid position. " + gridPosition, 0, 25);
        text("Tile Rotation: " + DIRECTION_NAMES[tileRotation], 0, 50);

        String s = "null";
        s = "[ " + TYPE_NAMES[mainFaces[0]];
        for(int i=1; i<mainFaces.length; i++){
            s += ", " + TYPE_NAMES[mainFaces[i]];
        }
        s += " ]";
        text("Main faces: " + s, 0, 75);

        s = "null";
        s = "[ " + TYPE_NAMES[surroundingFaces[0]];
        for(int i=1; i<surroundingFaces.length; i++){
            s += ", " + TYPE_NAMES[surroundingFaces[i]];
        }
        s += " ]";
        text("Surrounding faces: " + s, 0, 100);

        s = "null";
        if( correctTileRotations != null ){
            s = "[ " + DIRECTION_NAMES[correctTileRotations.get(0)];
            for(int i=1; i<correctTileRotations.size(); i++){
                s += ", " + DIRECTION_NAMES[correctTileRotations.get(i)];
            }
            s += " ]";
        }
        text("Correct rotations: " + s, 0, 125);

        text("Correct rotations index: " + correctTileRotationsIndex, 0, 150);




        popStyle();
        popMatrix();
    }

    private void drawHighlightedPlacement(VectorInt gridMousePosition){
        pushMatrix();
        pushStyle();
        
        translate(targetMargin, targetMargin);
        rectMode(CORNER);
        noStroke();
        fill(255, 120);
        rect(gridMousePosition.x*TILE_SIZE, gridMousePosition.y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
        
        popStyle();
        popMatrix();
    }

    private void drawNextTile(){
        // get bottom right corner location
        float boxDelta = 0.2f;
        float boxSize = height * boxDelta;
        PVector drawLoc = new PVector(width - boxSize, 0);
        float padding = height * boxDelta * 0.1f;
        PVector frameSize = new PVector(boxSize-padding*2, boxSize-padding*2);

        pushMatrix();

        translate(drawLoc.x, drawLoc.y);

        fill(grayBoxing);
        stroke(30);
        strokeWeight(2);
        rectMode(CORNER);
        rect(0, 0, boxSize, boxSize, 0, 0, 0, 15);

        translate(padding, padding);
        imageMode(CORNER);
        image(gc.getNextSprite(), 0, 0, frameSize.x, frameSize.y);
        
        popMatrix();
    }

    private void drawConditionalButton(){

        fill(grayBoxing);
        stroke(30);
        strokeWeight(2);
        rectMode(CORNER);
        rect(drawLoc.x, drawLoc.y, buttonBoxSize.x, buttonBoxSize.y);

        ellipseMode(RADIUS);
        
        if( isInsideButton(this.CANCEL) )
            fill(220, 100, 100);
        else
            fill(255, 100, 100);
        ellipse(buttonCancelLoc.x, buttonCancelLoc.y, buttonRadius, buttonRadius);

        if( isInsideButton(this.CONFIRM) )
            fill(100, 220, 100);
        else   
            fill(100, 255, 100);
        ellipse(buttonConfirmLoc.x, buttonConfirmLoc.y, buttonRadius, buttonRadius);
    }

    private boolean isInsideButton(int button){
        PVector mousePosition = new PVector(mouseX, mouseY);
        PVector differensVector;
        if( gc.isPreviewingPlacement() ){
            if( button == this.CANCEL )
                differensVector = PVector.sub(buttonCancelLoc, mousePosition);
            else if( button == this.CONFIRM ){
                differensVector = PVector.sub(buttonConfirmLoc, mousePosition);
            }
            else return false;
        }
        else return false;


        float magnitude = differensVector.mag();

        if( magnitude > buttonRadius)
            return false;

        return true;
    }

    public boolean isInsideUI(){
        // check button
        PVector mousePos = new PVector(mouseX, mouseY);
        PVector buttonPanelMax = new PVector(drawLoc.x + buttonBoxSize.x, drawLoc.y + buttonBoxSize.y);

        if( mousePos.x >= drawLoc.x && mousePos.y >= drawLoc.y &&
        mousePos.x <= buttonPanelMax.x && mousePos.y <= buttonPanelMax.y)
            return true;
        
        return false;
    }

    public int LeftMousePressed(){
        this.leftMousePressed = true;
        if( isInsideButton(this.CANCEL) )
            return this.CANCEL;
        else if( isInsideButton(this.CONFIRM) )
            return this.CONFIRM;
        else
            return this.NONE;
    }

    // getters
    public PVector getCancelButtonLocation(){
        return this.buttonCancelLoc;
    }
    
    public PVector getConfirmButtonLocation(){
        return this.buttonConfirmLoc;
    }
}
class Vector extends PVector{
    Vector(float x, float y){
        super(x, y);
    }

    public VectorInt snapToGrid(){
        int x = PApplet.parseInt(this.x / TILE_SIZE) * TILE_SIZE;
        int y = PApplet.parseInt(this.y / TILE_SIZE) * TILE_SIZE;
        return new VectorInt(x, y);
    }

    public VectorInt returnGridPosition(){
        int x = PApplet.parseInt(this.x / TILE_SIZE);
        int y = PApplet.parseInt(this.y / TILE_SIZE);
        return new VectorInt(x, y);
    }
}
class VectorInt{
    public int x, y;

    VectorInt(int x, int y){
        this.x = x;
        this.y = y;
    }

    public VectorInt returnGridPosition(){
        int x = PApplet.parseInt(this.x / TILE_SIZE);
        int y = PApplet.parseInt(this.y / TILE_SIZE);
        return new VectorInt(x, y);
    }
    
    public VectorInt scaleToGrid(){
        int x = PApplet.parseInt(this.x * TILE_SIZE);
        int y = PApplet.parseInt(this.y * TILE_SIZE);
        return new VectorInt(x, y);
    }
    
    public VectorInt asNew(){
        return new VectorInt(this.x, this.y);
    }

    // OPERATIONS

    public VectorInt mult(int d){
        this.x = this.x * d;
        this.y = this.y * d;
        return this;
    }

    public VectorInt mult(float d){
        this.x = PApplet.parseInt(this.x * d);
        this.y = PApplet.parseInt(this.y * d);
        return this;
    }

    public VectorInt div(int d){
        this.x = this.x / d;
        this.y = this.y / d;
        return this;
    }

    public VectorInt div(float d){
        this.x = PApplet.parseInt(this.x / d);
        this.y = PApplet.parseInt(this.y / d);
        return this;
    }
    
    @Override
    public String toString(){
        return "(" + this.x + ", " + this.y + ")";
    }
}


  public void settings() { size(1500, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
