/* autogenerated by Processing revision 1286 on 2024-01-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {

GameController gc;

final int TILE_SIZE = 100;

 public void setup(){
    /* size commented out by preprocessor */;

    gc = new GameController();
}

 public void draw(){
    background(0);

    gc.update();
    gc.render();
}


 public void mousePressed(){
    if(mouseButton == LEFT){
        gc.leftMousePressed();
    }
    if( mouseButton == RIGHT){
        gc.rightMousePressed();
    }
}
class GameController{
    ArrayList<Tile> placedTiles;

    // handlers
    GraphicsHandler gh;
    UIHandler uih;

    // sprites
    PImage[] sprites;
    int spriteSize = 24;
    int iSprite;

    // mouse position snapped to a grid
    private VectorInt snappedMousePos;

    // input
    private boolean isPreviewingPlacement = false;
    private boolean hasConfirmedPlacement = false;
    private Tile previewTile;



    // constructor
    public GameController(){
        placedTiles = new ArrayList<Tile>();
        sprites = new PImage[spriteSize];

        // init handlers
        gh = new GraphicsHandler(this);
        uih = new UIHandler(this);
        
        // initialize all spries
        for(int i = 0; i < spriteSize; i++){
            String s = str(i);
            while( s.length() < 2)
                s = "0" + s;
            sprites[i] = loadImage("resources/sprites/sprite_" + s + ".png"); // idk why these images are in png lol
        }
        selectNewRandomSprite();

        //add middle tile
        Vector middlePos = new Vector(width/2, height/2);
        VectorInt middleGridPos = middlePos.returnGridPosition();
        Tile starterTile = new Tile(middleGridPos, sprites[14]);
        placedTiles.add(starterTile);
    }





    // main methods

     public void update(){
        Vector mousePosition = new Vector(mouseX, mouseY);
        snappedMousePos = mousePosition.snapToGrid();

        if(this.isPreviewingPlacement && this.hasConfirmedPlacement){
            placeTile();
            clearPlacementFlags();
            selectNewRandomSprite();
        }
    }

    public void render(){
        gh.render();
        uih.render();
    }





    // Functionality

     public void selectNewRandomSprite(){
        iSprite = PApplet.parseInt(random(0, spriteSize));
    }

     public void placeTile(){
        Tile newTile = new Tile(previewTile.getGridPosition(), sprites[iSprite], previewTile.getRotation());
        this.placedTiles.add(newTile);
    }

     public void clearPlacementFlags(){
        previewTile = null;
        this.hasConfirmedPlacement = false;
        this.isPreviewingPlacement = false;
    }



    // input

    public void leftMousePressed(){
        if( uih.isInsideUI() ){
            int buttonPressed = uih.leftMousePressed();
            if( buttonPressed == uih.CANCEL){
                clearPlacementFlags();
            }
            else if( buttonPressed == uih.CONFIRM){
                this.hasConfirmedPlacement = true;
            }
            return;
        }

        VectorInt previewLocation = this.snappedMousePos.returnGridPosition();

        if( !validTilePlacement(previewLocation) )
            return;

        previewTile = new Tile(previewLocation, sprites[iSprite]);
        previewTile.addHighlight();
        this.isPreviewingPlacement = true;
    }

    public void rightMousePressed(){
        if( isPreviewingPlacement ){
            previewTile.rotateTile();
        }
    }





    // boolean methods

    public boolean validTilePlacement(VectorInt gridPosition){
        // validity
        if( !hasNeighbours(gridPosition) ){
            return false;
        }
        for(Tile refTile : this.placedTiles){
            VectorInt refTile_position = refTile.getGridPosition();
            if( refTile_position.x == gridPosition.x && refTile_position.y == gridPosition.y ){
                return false;
            }
        }

        return true;
    }

     public boolean hasNeighbours(VectorInt gridPosition){
        int[][] theFourHorsemen = {{-1,0}, {0,-1}, {1,0}, {0,1}};
        for(Tile t : placedTiles){
            VectorInt tPos = t.getGridPosition();
            for(int i = 0; i < 4; i++){
                int dX = (gridPosition.x + theFourHorsemen[i][0]);
                int dY = (gridPosition.y + theFourHorsemen[i][1]);
                if( tPos.x == dX && tPos.y == dY)
                    return true;
            }
        }

        return false;
    }





    // getters

    public ArrayList<Tile> getPlacedTiles(){
        return this.placedTiles;
    }

    public Tile getPreviewTile(){
        return this.previewTile;
    }

    public boolean isPreviewingPlacement(){
        return this.isPreviewingPlacement;
    }

    public VectorInt getSnappedMousePos(){
        return this.snappedMousePos;
    }

    public PImage getNextSprite(){
        return this.sprites[iSprite];
    }
}
class GraphicsHandler{
    // Game Controller reference
    private GameController gc;

    public GraphicsHandler(GameController gc){
        this.gc = gc;
    }

    public void render(){
        renderTiles();
        if(gc.isPreviewingPlacement())
            renderPreviewTile();
    }

    private void renderTiles(){
        ArrayList<Tile> placedTiles = gc.getPlacedTiles();
        for(Tile t : placedTiles){
            t.draw();
        }
    }

    private void renderPreviewTile(){
        Tile previewTile = gc.getPreviewTile();
        previewTile.draw();
    }
}
class Tile{
    VectorInt gridPosition;
    int c;
    PImage sprite;

    // directions
    public final int NORTH = 0;
    public final int EAST  = 1;
    public final int SOUTH = 2;
    public final int WEST  = 3;
    int rotation = 0;

    // connections
    TileConnections tc;

    //tint
    boolean addHighlight = false;

    public Tile(VectorInt gridPosition, PImage sprite){
        this.gridPosition = gridPosition;
        this.sprite = sprite;
        this.rotation = this.NORTH;

        tc = new TileConnections(this);
    }

    public Tile(VectorInt gridPosition, PImage sprite, int rotation){
        this.gridPosition = gridPosition;
        this.sprite = sprite;
        this.rotation = rotation;
    }



    public void draw(){
        VectorInt drawPosition = gridPosition.scaleToGrid();
        
        pushMatrix();
        translate(drawPosition.x + TILE_SIZE/2, drawPosition.y + TILE_SIZE/2);
        pushStyle();
        imageMode(CENTER);

        // change direction if needed
        rotate(rotation * HALF_PI);

        if( this.addHighlight )
            tint(170, 170, 170, 150);
        image(sprite, 0, 0, TILE_SIZE, TILE_SIZE);
        popStyle();
        popMatrix();
    }

    public VectorInt getGridPosition(){
        return this.gridPosition;
    }

    public int getRotation(){
        return this.rotation;
    }

    public void rotateTile(){
        if( rotation < 3 )
            rotation += 1;
        else
            rotation = 0;
    }

    public void addHighlight(){
        this.addHighlight = true;
    }
}
class TileConnections{
    // enums
    public final int GRASS      = 0; // default int value is 0
    public final int ROAD       = 1;
    public final int ROAD_NORTH = 2;
    public final int ROAD_EAST  = 3;
    public final int ROAD_SOUTH = 4;
    public final int ROAD_WEST  = 5;
    public final int CITY       = 6;
    public final int CITYNORTH  = 7;
    public final int CITYEAST   = 8;
    public final int CITYSOUTH  = 9;
    public final int CITYWEST   = 10;
    
    //
    int[][] array;

    // Parent tile reference
    Tile parentTile;

    public TileConnections(Tile parentTile){
        this.parentTile = parentTile;

        array = new int[4][];
        for(int i = 0; i < 4; i++){
            print(array[i]);
        }
    }
}
class UIHandler{
    // GameController reference
    GameController gc;


    // color scheme
    int grayBoxing = color(90, 90, 110);

    // locations of button controls
    PVector buttonCancelLoc;
    PVector buttonConfirmLoc;

    // leftMouseDown
    boolean leftMousePressed = false;

    // references
    final int CANCEL = 0;
    final int CONFIRM = 1;
    final int NONE = 3;
    
    // conditional button parameters
    PVector buttonBoxSize   = new PVector(width*0.05f, height*0.16f);
    float padding           = buttonBoxSize.x*0.25f;
    float boxRadius         = buttonBoxSize.x*0.5f;
    float buttonRadius      = boxRadius*0.75f;
    PVector drawLoc         = new PVector(width - (padding + buttonBoxSize.x), height - (padding + buttonBoxSize.y));

    public UIHandler(GameController gc){
        this.gc = gc;

        
        buttonCancelLoc = new PVector(drawLoc.x + boxRadius, drawLoc.y + boxRadius);
        buttonConfirmLoc = new PVector(drawLoc.x + boxRadius, drawLoc.y + buttonBoxSize.y - boxRadius);
    }


    public void render(){
        VectorInt snappedMousePos = gc.getSnappedMousePos();

        if( gc.validTilePlacement(snappedMousePos.returnGridPosition() ) )
            drawHighlightedPlacement(snappedMousePos);
        
        drawNextTile();

        if( gc.isPreviewingPlacement() )
            drawConditionalButton();
    }

    private void drawHighlightedPlacement(VectorInt drawLoc){
        pushMatrix();
        pushStyle();
        
        translate(drawLoc.x, drawLoc.y);
        rectMode(CORNER);
        noStroke();
        fill(255, 120);
        rect(0, 0, TILE_SIZE, TILE_SIZE);
        
        popStyle();
        popMatrix();
    }

    private void drawNextTile(){
        // get bottom right corner location
        float boxDelta = 0.2f;
        float boxSize = height * boxDelta;
        PVector drawLoc = new PVector(width - boxSize, 0);
        float padding = height * boxDelta * 0.1f;
        PVector frameSize = new PVector(boxSize-padding*2, boxSize-padding*2);

        pushMatrix();

        translate(drawLoc.x, drawLoc.y);

        fill(grayBoxing);
        stroke(30);
        strokeWeight(2);
        rectMode(CORNER);
        rect(0, 0, boxSize, boxSize, 0, 0, 0, 15);

        translate(padding, padding);
        imageMode(CORNER);
        image(gc.getNextSprite(), 0, 0, frameSize.x, frameSize.y);
        
        popMatrix();
    }

    private void drawConditionalButton(){

        fill(grayBoxing);
        stroke(30);
        strokeWeight(2);
        rectMode(CORNER);
        rect(drawLoc.x, drawLoc.y, buttonBoxSize.x, buttonBoxSize.y);

        ellipseMode(RADIUS);
        
        if( isInsideButton(this.CANCEL) )
            fill(220, 100, 100);
        else
            fill(255, 100, 100);
        ellipse(buttonCancelLoc.x, buttonCancelLoc.y, buttonRadius, buttonRadius);

        if( isInsideButton(this.CONFIRM) )
            fill(100, 220, 100);
        else   
            fill(100, 255, 100);
        ellipse(buttonConfirmLoc.x, buttonConfirmLoc.y, buttonRadius, buttonRadius);
    }

    private boolean isInsideButton(int button){
        PVector mousePosition = new PVector(mouseX, mouseY);
        PVector differensVector;
        if( gc.isPreviewingPlacement() ){
            if( button == this.CANCEL )
                differensVector = PVector.sub(buttonCancelLoc, mousePosition);
            else if( button == this.CONFIRM ){
                differensVector = PVector.sub(buttonConfirmLoc, mousePosition);
            }
            else return false;
        }
        else return false;


        float magnitude = differensVector.mag();

        if( magnitude > buttonRadius)
            return false;

        return true;
    }

    public boolean isInsideUI(){
        // check button
        PVector mousePos = new PVector(mouseX, mouseY);
        PVector buttonPanelMax = new PVector(drawLoc.x + buttonBoxSize.x, drawLoc.y + buttonBoxSize.y);

        if( mousePos.x >= drawLoc.x && mousePos.y >= drawLoc.y &&
        mousePos.x <= buttonPanelMax.x && mousePos.y <= buttonPanelMax.y)
            return true;
        
        return false;
    }

    public int leftMousePressed(){
        this.leftMousePressed = true;
        if( isInsideButton(this.CANCEL) )
            return this.CANCEL;
        else if( isInsideButton(this.CONFIRM) )
            return this.CONFIRM;
        else
            return this.NONE;
    }

    // getters
    public PVector getCancelButtonLocation(){
        return this.buttonCancelLoc;
    }
    
    public PVector getConfirmButtonLocation(){
        return this.buttonConfirmLoc;
    }
}
class Vector extends PVector{
    Vector(float x, float y){
        super(x, y);
    }

    public VectorInt snapToGrid(){
        int x = PApplet.parseInt(this.x / TILE_SIZE) * TILE_SIZE;
        int y = PApplet.parseInt(this.y / TILE_SIZE) * TILE_SIZE;
        return new VectorInt(x, y);
    }

    public VectorInt returnGridPosition(){
        int x = PApplet.parseInt(this.x / TILE_SIZE);
        int y = PApplet.parseInt(this.y / TILE_SIZE);
        return new VectorInt(x, y);
    }
}
class VectorInt{
    public int x, y;

    VectorInt(int x, int y){
        this.x = x;
        this.y = y;
    }

    public VectorInt returnGridPosition(){
        int x = PApplet.parseInt(this.x / TILE_SIZE);
        int y = PApplet.parseInt(this.y / TILE_SIZE);
        return new VectorInt(x, y);
    }
    
    public VectorInt scaleToGrid(){
        int x = PApplet.parseInt(this.x * TILE_SIZE);
        int y = PApplet.parseInt(this.y * TILE_SIZE);
        return new VectorInt(x, y);
    }

    @Override
    public String toString(){
        return "(" + this.x + ", " + this.y + ")";
    }

    public VectorInt mult(int d){
        this.x = this.x * d;
        this.y = this.y * d;
        return this;
    }

    public VectorInt mult(float d){
        this.x = PApplet.parseInt(this.x * d);
        this.y = PApplet.parseInt(this.y * d);
        return this;
    }

    public VectorInt div(int d){
        this.x = this.x / d;
        this.y = this.y / d;
        return this;
    }

    public VectorInt div(float d){
        this.x = PApplet.parseInt(this.x / d);
        this.y = PApplet.parseInt(this.y / d);
        return this;
    }


    public VectorInt asNew(){
        return new VectorInt(this.x, this.y);
    }
}


  public void settings() { size(1500, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
