/* autogenerated by Processing revision 1286 on 2024-01-30 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.security.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class tileConnectionHelper extends PApplet {

/*
    Author: SolidSoups
    Date: 1/25/2024
 */


// FINALS
public final int GRASS      = 0; // default int value is 0
public final int ROAD       = 1;
public final int CITY       = 2;
public final String[] typeNames = {
    "grass", 
    "road",
    "city",
};

public final int NORTH = 0;
public final int EAST  = 1;
public final int SOUTH = 2;
public final int WEST  = 3;
public final String[] directionNames = {
    "north ^",
    "east >",
    "south V",
    "west <"
};

// SPRITES
PImage[] tileSprites;
int tileSpritesSize = 24;

// TILE OBJECTS
ArrayList<Tile> tiles;

// COUNTERS
int spriteIndex = 0;
int currentDirection = NORTH;

// COLORS
int spriteIndexColorUnlocked   = color(0,255,0);
int spriteIndexColorLocked   = color(255,0,0);
int portTypeColor = color(0, 0, 255);
int portDirColor  = color(120, 255, 120);
int selDirColor   = color(200, 200, 200);

// POSITIONS TO DISPLAY PORT INFORMATION
PVector[] positions = {
    new PVector(300, 50),
    new PVector(500, 250),
    new PVector(300, 350),
    new PVector(100, 250)
}; 





// SETUP--
 public void setup(){
    /* size commented out by preprocessor */;

    // Initialize arrays
    tiles = new ArrayList<Tile>();
    tileSprites = new PImage[tileSpritesSize];

    // create array of our loaded tiles
    ArrayList<Tile> loadedTiles = new ArrayList<Tile>();
    loadedTiles = loadTilesFromJSON();

    // here we create a list of the loaded tiles id's, so we know which sprites have been saved
    IntList loadedIDs = new IntList();
    for(Tile t : loadedTiles)
        loadedIDs.append(t.getID());
    loadedIDs.sort();

    // loop through count of tile sprites, load sprites into PImage array, add a loaded tile if the id exists in 'loadedIDs', otherwise load a generic tile
    for(int i = 0; i < tileSpritesSize; i++){
        // format index as "01" or "10", load image into sprite array
        String s = str(i);
        while( s.length() < 2)
            s = "0" + s;
        tileSprites[i] = loadImage("resources/sprites/sprite_" + s + ".png");

        // load tiles if we have saved them and reset the loop if so
        if( loadedIDs.size() >= 1 )
            if( i == loadedIDs.get(0) ){
                loadedIDs.remove(0);
                spriteIndex = i;
                tiles.add(loadedTiles.get(i));
                continue;
            }
        
        // add a generic tile since we have not loaded it
        tiles.add(new Tile(i));
    }
}






// DRAW--
 public void draw(){
    background(0);

    // change ID Text color depending on lock state
    if( !tiles.get(spriteIndex).getLock() )
        fill(spriteIndexColorUnlocked);
    else
        fill(spriteIndexColorLocked);
    
    // display ID Text in upper left corner
    textSize(50);
    textAlign(TOP, TOP);
    text("ID: " + str(spriteIndex), 30, 10);

    // display current sprite in the middle
    image(tileSprites[spriteIndex], 100, 100, 400, 400);

    // set some styles
    textSize(30);
    textAlign(CENTER, TOP);

    // get all port types
    int[] portTypes = tiles.get(spriteIndex).getPortTypes();
    // loop through all four ports from North to West clockwise
    for(int i=0; i<4; i++){
        // if we are editing the current port, display a rect as a marker
        if(i == currentDirection){
            pushMatrix();
            translate(width/2, height/2);
            fill(selDirColor);
            rotate(currentDirection * HALF_PI);
            rectMode(CENTER);
            rect(0, -260, 100, 50);
            popMatrix();
        }

        // display the port at that direction
        String currentPortTypeName = typeNames[portTypes[i]];
        fill(255);
        text(currentPortTypeName, positions[i].x + 1, positions[i].y + 0.7f);
        fill(portTypeColor);
        text(currentPortTypeName, positions[i].x, positions[i].y);

        // loop through all connections for current port, create a list of their string representations
        boolean[] connections = tiles.get(spriteIndex).getPortConnections(i);
        String s = "";
        for(int n=0; n<4; n++){
            if( connections[n] )
                s += directionNames[n] + "\n";
        }

        // display list of connections for current port under the portType, with a slight stroke
        fill(0);
        text(s, positions[i].x + 1, positions[i].y + 30.7f);
        fill(portDirColor);
        text(s, positions[i].x, positions[i].y + 30f);
    }
}





// KEY PRESS EVENTS
 public void keyPressed(){
    // Next tile 
    if(key == 'e'){
        spriteIndex++;
        if( spriteIndex >= tileSpritesSize )
            spriteIndex = 0;
    }
    // Previous tile
    if(key == 'q'){
        spriteIndex--;
        if( spriteIndex < 0)
            spriteIndex = tileSpritesSize - 1;
    }

    // Lock editing for current tile
    if(keyCode == DOWN){
        tiles.get(spriteIndex).flipLock();
    }

    // Save all locked tiles
    if(key == 'b'){
        saveTilesAsJSON();
    }

    // enable north connection
    if(key == 'w'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, NORTH);
    }
    // enable east connection
    if(key == 'd'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, EAST);
    }
    // enable south connection
    if(key == 's'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, SOUTH);
    }
    // enable west connection
    if(key == 'a'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, WEST);
    }


    // cycle current port clockswise
    if(keyCode == RIGHT){
        currentDirection++;
        if( currentDirection >= 4 )
            currentDirection = 0;
    }
    // cycle current port counter-clockwise
    if(keyCode == LEFT){
        currentDirection--;
        if( currentDirection < 0)
            currentDirection = 3;
    }

    // cycle portTypes
    if(keyCode == UP){
        int i = tiles.get(spriteIndex).getPortType(currentDirection);
        i++;
        if( i >= 3 )
            i = 0;
        tiles.get(spriteIndex).setPortType(currentDirection, i);
    }
}






// Save all locked Tile objects as a JSON file
 public void saveTilesAsJSON(){
    println("\nSaving locked tiles as JSON file!");
    JSONArray tilePieces = new JSONArray();
    
    for(Tile t : tiles){
        // return if Tile object t is not locked
        if( !t.getLock() ) continue;

        println("---Looping through tile ID: " + t.getID());

        // Create a Tile JSONObject
        JSONObject tile    = new JSONObject();

        // Set the ID
        tile.setInt("id", t.getID());
        println("Set tile ID...");

        // set portTypes as an array such as ex. {GRASS, ROAD, CITY, ROAD}
        JSONArray  portTypes = new JSONArray();
        for(int i=0; i<4; i++){ 
            portTypes.append(t.getPortType(i));
        }
        tile.setJSONArray("portTypes", portTypes);
        println("Set tile portTypes...");

        // set a portConnections as a 2D boolean array, x being the origin port and y being if it connects to that port
        JSONArray portsConnectionsX = new JSONArray();
        for(int x=0; x<4; x++){
            boolean[] portConnections = t.getPortConnections(x);
            JSONArray portsConnectionsY = new JSONArray();
            for(int y = 0; y<4; y++){
                portsConnectionsY.append(portConnections[y]);
            }
            portsConnectionsX.append(portsConnectionsY);
        }
        tile.setJSONArray("portConnections", portsConnectionsX);
        println("Set tile portConnections...");

        // append tile to json tile array
        tilePieces.append(tile);
    }

    // Save array
    saveJSONArray(tilePieces, "data/tileConnections.json");
    println("Data saved");
}






// Load all saved Tile objects and return an ArrayList<Tile> object
 public ArrayList<Tile> loadTilesFromJSON(){
    JSONArray tilePieces = loadJSONArray("data/tileConnections.json");
    ArrayList<Tile> loadedTiles = new ArrayList<Tile>();

    // loop through available loaded Tile objects
    for (int i=0; i < tilePieces.size(); i++){
        // variables for each tile object
        int tileID;
        int[] portTypes = new int[4];
        boolean[][] portConnections = new boolean[4][4];
        
        // load tile object at index
        JSONObject tile = tilePieces.getJSONObject(i);

        // retrieve tile id
        tileID = tile.getInt("id");

        // retrieve tile portTypes
        JSONArray portTypesArray   = tile.getJSONArray("portTypes");
        portTypes = portTypesArray.toIntArray();

        // retrieve boolean portsConnections
        JSONArray portsConnectionsX = tile.getJSONArray("portConnections");
        for(int x=0; x<4; x++){
            JSONArray portsConnectionsY = portsConnectionsX.getJSONArray(x);
            for(int y=0; y<4; y++){
                portConnections[x][y] = portsConnectionsY.getBoolean(y);
            }
        }

        // add a tile with this information
        Tile newTile = new Tile(tileID, portTypes, portConnections);
        loadedTiles.add(newTile);
    }
    
    println("\nLoaded " + loadedTiles.size() + " tiles from JSON file!");
    return loadedTiles;
}


class Tile{
    // organized as North, East, South, West: with each element being either a City, Road or Grass.
    int[] portTypes = {GRASS, GRASS, GRASS, GRASS};
    // organized as North, East, South, West: with each 4 elements being a collection of which direction the port connects to.
    boolean[][] portConnections;

    // lock editing
    private boolean lock = false;

    // sprite id for tile
    int id;

    Tile(int id){
        this.id = id;
        this.portConnections = new boolean[4][4];
    }

    // constructor for creating a loaded tile object
    Tile(int id, int[] portTypes, boolean[][] portConnections){
        this.id = id;
        this.portTypes = portTypes;
        this.portConnections = portConnections;
        this.lock = true;
    }

    // GETTER METHODS

    public int getID(){
        return this.id;
    }

    public boolean getLock(){
        return this.lock;
    }

    public int[] getPortTypes(){
        return this.portTypes;
    }

    // get connections for a specific port i
    public boolean[] getPortConnections(int i){
        return this.portConnections[i];
    }

    // get portType for a specific port i
    public int getPortType(int i){
        return this.portTypes[i];
    }

    // set portType to value for a specific port i
    public void setPortType(int i, int value){
        if(lock) return;
        if( value < 0 || value >= 3 )
            throw new InvalidParameterException("value out of bounds.");
        this.portTypes[i] = value;
    }

    // flip the lock state
    public void flipLock(){
        this.lock = !lock;
    }

    // enable a connection between a port to another
    public void flipPortConnection(int fromPort, int toPort){
        if( lock ) return;
        if( fromPort == toPort )
            return;
        this.portConnections[fromPort][toPort] = !this.portConnections[fromPort][toPort];
    }

    // returns a string of the lock state
     public String getLockString(){
        if(lock) return "locked";
        return "unlocked";
    }

    // to string method
    public String toString(){
        String s = "\nID: " + this.id + " " + this.getLockString() + "\n";
        for(int i=0; i<4; i++){
            s += typeNames[this.portTypes[i]] + ": ";
            for(int y=0; y<4; y++){
                s += this.portConnections[i][y] + " ";
            }
            s += "\n";
        }
        return s;
    }

}


  public void settings() { size(600, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "tileConnectionHelper" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
