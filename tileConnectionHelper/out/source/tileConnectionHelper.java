/* autogenerated by Processing revision 1286 on 2024-01-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.security.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class tileConnectionHelper extends PApplet {


// FINALS
public final int GRASS      = 0; // default int value is 0
public final int ROAD       = 1;
public final int CITY       = 2;
public final String[] typeNames = {
    "grass", 
    "road",
    "city",
};

public final int NORTH = 0;
public final int EAST  = 1;
public final int SOUTH = 2;
public final int WEST  = 3;
public final String[] directionNames = {
    "north",
    "east",
    "south",
    "west"
};

// SPRITES
PImage[] tileSprites;
int tileSpritesSize = 24;

// TILE OBJECTS
ArrayList<Tile> tiles;

// COUNTERS
int spriteIndex = 0;
int currentDirection = NORTH;

// COLORS
int spriteIndexColorUnlocked   = color(0,255,0);
int spriteIndexColorLocked   = color(255,0,0);
int portTypeColor = color(0, 0, 255);
int portDirColor  = color(120, 255, 120);
int selDirColor   = color(200, 200, 200);





// SETUP--
 public void setup(){
    /* size commented out by preprocessor */;

    // Initialize arrays
    tiles = new ArrayList<Tile>();
    tileSprites = new PImage[tileSpritesSize];


    ArrayList<Tile> loadedTiles = new ArrayList<Tile>();
    loadedTiles = loadTilesFromJSON();

    IntList loadedIDs = new IntList(); // keep track of what id's we haven't loaded
    for(Tile t : loadedTiles)
        loadedIDs.append(t.getID());
    loadedIDs.sort();

    for(int i = 0; i < tileSpritesSize; i++){
        String s = str(i);
        while( s.length() < 2)
            s = "0" + s;
        tileSprites[i] = loadImage("resources/sprites/sprite_" + s + ".png");

        if( loadedIDs.size() >= 1 )
            if( i == loadedIDs.get(0) ){
                loadedIDs.remove(0);
                tiles.add(loadedTiles.get(i));
                continue;
            }
        
        tiles.add(new Tile(i));
    }
}






// DRAW--
 public void draw(){
    background(0);

    // draw current sprite index
    if( !tiles.get(spriteIndex).getLock() )
        fill(spriteIndexColorUnlocked);
    else
        fill(spriteIndexColorLocked);
    
    textSize(50);
    textAlign(TOP, TOP);
    text("ID: " + str(spriteIndex), 30, 10);

    // draw current sprite
    image(tileSprites[spriteIndex], 100, 100, 400, 400);

    // draw all connections on current sprite
    pushStyle();
    textSize(30);
    textAlign(CENTER, TOP);

    PVector[] positions = {
        new PVector(300, 50),
        new PVector(500, 250),
        new PVector(300, 350),
        new PVector(100, 250)
    }; 
    int[] portTypes = tiles.get(spriteIndex).getPortTypes();
    
    for(int i=0; i<4; i++){
        if(i == currentDirection){
            pushMatrix();
            translate(width/2, height/2);
            fill(selDirColor);
            rotate(currentDirection * HALF_PI);
            rectMode(CENTER);
            rect(0, -260, 100, 50);
            popMatrix();
        }

        String directionName = typeNames[portTypes[i]];
        fill(255);
        text(directionName, positions[i].x + 1, positions[i].y + 0.7f);
        fill(portTypeColor);
        text(directionName, positions[i].x, positions[i].y);

        boolean[] connections = tiles.get(spriteIndex).getPortConnections(i);
        String s = "";
        for(int n=0; n<4; n++){
            if( connections[n] )
                s += directionNames[n] + "\n";
        }
        fill(0);
        text(s, positions[i].x + 1, positions[i].y + 30.7f);
        fill(portDirColor);
        text(s, positions[i].x, positions[i].y + 30f);
    }
}








 public void keyPressed(){
    // switch sprite
    if(key == 'e'){
        spriteIndex++;
        if( spriteIndex >= tileSpritesSize )
            spriteIndex = 0;
    }
    if(key == 'q'){
        spriteIndex--;
        if( spriteIndex < 0)
            spriteIndex = tileSpritesSize - 1;
    }

    // lock tile editing
    if(key == 'p'){
        tiles.get(spriteIndex).flipLock();
    }

    // save connections
    if(key == 'b'){
        saveTilesAsJSON();
    }

    // switch current port directions
    if(key == 'w'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, NORTH);
    }
    if(key == 'd'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, EAST);
    }
    if(key == 's'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, SOUTH);
    }
    if(key == 'a'){
        tiles.get(spriteIndex).flipPortConnection(currentDirection, WEST);
    }


    // switch port
    if(keyCode == RIGHT){
        currentDirection++;
        if( currentDirection >= 4 )
            currentDirection = 0;
    }
    if(keyCode == LEFT){
        currentDirection--;
        if( currentDirection < 0)
            currentDirection = 3;
    }

    // cycle the port type
    if(keyCode == UP){
        int i = tiles.get(spriteIndex).getPortType(currentDirection);
        i++;
        if( i >= 3 )
            i = 0;
        tiles.get(spriteIndex).setPortType(currentDirection, i);
    }
}







 public void saveTilesAsJSON(){
    println("\nSaving locked tiles as JSON file!");
    JSONArray tilePieces = new JSONArray();

    for(Tile t : tiles){
        if( !t.getLock() ) continue;
        println("---Looping through tile ID: " + t.getID());

        // create tile object
        JSONObject tile    = new JSONObject();

        // set id
        JSONObject tileID = new JSONObject();
        tile.setInt("id", t.getID());
        println("Set tile ID...");

        // set a port array as (key, value) --> ("portTypes", {ROAD, CITY, GRASS, GRASS})
        JSONArray  portTypes = new JSONArray();
        for(int i=0; i<4; i++){ 
            portTypes.append(t.getPortType(i));
        }
        tile.setJSONArray("portTypes", portTypes);
        println("Set tile portTypes...");

        // set a port array as (key, value) --> ("portConnections", {{WEST, SOUTH}, null, {NORTH}, null})
        JSONArray portsConnectionsX = new JSONArray();
        for(int x=0; x<4; x++){
            boolean[] portConnections = t.getPortConnections(x);
            JSONArray portsConnectionsY = new JSONArray();
            for(int y = 0; y<4; y++){
                portsConnectionsY.append(portConnections[y]);
            }
            portsConnectionsX.append(portsConnectionsY);
        }
        tile.setJSONArray("portConnections", portsConnectionsX);
        println("Set tile portConnections...");

        // append tile to json tile array
        tilePieces.append(tile);
    }

    saveJSONArray(tilePieces, "data/tileConnections.json");
    println("Data saved");
}







 public ArrayList<Tile> loadTilesFromJSON(){
    JSONArray tilePieces = loadJSONArray("data/tileConnections.json");
    ArrayList<Tile> loadedTiles = new ArrayList<Tile>();

    for (int i=0; i < tilePieces.size(); i++){
        int tileID;
        int[] portTypes = new int[4];
        boolean[][] portConnections = new boolean[4][4];
        
        // load tile object at index
        JSONObject tile = tilePieces.getJSONObject(i);

        // retrieve tile id
        tileID = tile.getInt("id");

        // retrieve tile portTypes
        JSONArray portTypesArray   = tile.getJSONArray("portTypes");
        portTypes = portTypesArray.toIntArray();

        // retrieve boolean portsConnections
        JSONArray portsConnectionsX = tile.getJSONArray("portConnections");
        for(int x=0; x<4; x++){
            JSONArray portsConnectionsY = portsConnectionsX.getJSONArray(x);
            for(int y=0; y<4; y++){
                portConnections[x][y] = portsConnectionsY.getBoolean(y);
            }
        }

        // add a tile with this information
        Tile newTile = new Tile(tileID, portTypes, portConnections);
        loadedTiles.add(newTile);
    }
    
    println("\nLoaded " + loadedTiles.size() + " tiles from JSON file!");
    return loadedTiles;
}


class Tile{
    // organized as North, East, South, West: with each element being either a City, Road or Grass.
    int[] portTypes = {GRASS, GRASS, GRASS, GRASS};
    // organized as North, East, South, West: with each 4 elements being a collection of which direction the port connects to.
    boolean[][] portConnections;

    // lock editing
    private boolean lock = false;

    // sprite id for tile
    int id;

    Tile(int id){
        this.id = id;
        this.portConnections = new boolean[4][4];
    }

    Tile(int id, int[] portTypes, boolean[][] portConnections){
        this.id = id;
        this.portTypes = portTypes;
        this.portConnections = portConnections;
        this.lock = true;
    }

    public int getID(){
        return this.id;
    }

    public int[] getPortTypes(){
        return this.portTypes;
    }

    public int getPortType(int i ){
        return this.portTypes[i];
    }

    public void setPortType(int i, int value){
        if(lock) return;
        if( value < 0 || value >= 3 )
            throw new InvalidParameterException("value out of bounds.");
        this.portTypes[i] = value;
    }

    public boolean[] getPortConnections(int i){
        return this.portConnections[i];
    }

    public void flipPortConnection(int i, int portDirection){
        if( lock ) return;
        if( i == portDirection )
            return;
        this.portConnections[i][portDirection] = !this.portConnections[i][portDirection];
    }

     public String getLockString(){
        if(lock) return "locked";
        return "unlocked";
    }

    public boolean getLock(){
        return this.lock;
    }

    public void flipLock(){
        this.lock = !lock;
    }

    public String toString(){
        String s = "\nID: " + this.id + " " + this.getLockString() + "\n";
        for(int i=0; i<4; i++){
            s += typeNames[this.portTypes[i]] + ": ";
            for(int y=0; y<4; y++){
                s += this.portConnections[i][y] + " ";
            }
            s += "\n";
        }
        return s;
    }

}


  public void settings() { size(600, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "tileConnectionHelper" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
